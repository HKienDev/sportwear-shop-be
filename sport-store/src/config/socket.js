import { Server } from 'socket.io';
import { logInfo, logError } from '../utils/logger.js';
import ChatMessage from '../models/ChatMessage.js';
import User from '../models/User.js';

let io;

export const initSocket = (server) => {
    io = new Server(server, {
        cors: {
            origin: [
                'http://localhost:3000',
                'https://sport-store-fe-graduation.vercel.app',
                'https://www.vjusport.com'
            ],
            methods: ['GET', 'POST'],
            credentials: true
        },
        pingTimeout: 60000,
        pingInterval: 25000,
        transports: ['websocket', 'polling'],
        allowEIO3: true // Cho ph√©p Engine.IO v3
    });

    // L∆∞u tr·ªØ th√¥ng tin user ƒë√£ k·∫øt n·ªëi
    const connectedUsers = new Map();
    // L∆∞u tr·ªØ th√¥ng tin admin ƒë√£ k·∫øt n·ªëi
    const connectedAdmins = new Set();
    // L∆∞u tr·ªØ th√¥ng tin socket ID v√† user ID
    const socketToUserId = new Map();
    // L∆∞u tr·ªØ th√¥ng tin user
    const userInfo = new Map();

    io.on('connection', (socket) => {
        logInfo(`Client connected: ${socket.id}`);

        // X·ª≠ l√Ω khi client x√°c ƒë·ªãnh danh t√≠nh
        socket.on('identifyUser', async (data) => {
            try {
                const { userId, userName, isAdmin } = data;
                logInfo(`IdentifyUser request from ${socket.id}:`, { userId, userName, isAdmin });
                
                if (isAdmin) {
                    // N·∫øu l√† admin, th√™m v√†o danh s√°ch admin
                    connectedAdmins.add(socket.id);
                    logInfo(`Admin identified with socket ${socket.id}`);
                    
                    // G·ª≠i x√°c nh·∫≠n l·∫°i cho admin
                    socket.emit('identified', { 
                        status: 'success', 
                        role: 'admin',
                        socketId: socket.id
                    });
                    
                    // Log s·ªë l∆∞·ª£ng admin hi·ªán t·∫°i
                    logInfo(`Current admin count: ${connectedAdmins.size}`);
                } else if (userId) {
                    // N·∫øu l√† user, th√™m v√†o danh s√°ch user
                    connectedUsers.set(userId, socket.id);
                    socketToUserId.set(socket.id, userId);
                    
                    // L·∫•y th√¥ng tin user t·ª´ database n·∫øu c√≥
                    let userData = { name: userName || 'Unknown User' };
                    if (userId && !userId.startsWith('temp_')) {
                        try {
                            const user = await User.findById(userId).select('fullname email phone');
                            if (user) {
                                userData = { 
                                    name: user.fullname || userName || 'Unknown User',
                                    email: user.email,
                                    phone: user.phone
                                };
                            }
                        } catch (error) {
                            logError(`Error fetching user ${userId}:`, error);
                        }
                    }
                    
                    userInfo.set(userId, userData);
                    const roomName = `user_${userId}`;
                    socket.join(roomName);
                    logInfo(`‚úÖ User ${userId} (${userData.name}) joined room: ${roomName}`);
                    logInfo(`üîç Current rooms for socket ${socket.id}:`, Array.from(socket.rooms));
                    
                    // G·ª≠i x√°c nh·∫≠n l·∫°i cho user
                    socket.emit('identified', { 
                        status: 'success', 
                        role: 'user',
                        userId: userId,
                        socketId: socket.id,
                        userInfo: userData
                    });
                } else {
                    logError(`Invalid identifyUser data from ${socket.id}:`, data);
                    socket.emit('identified', { 
                        status: 'error', 
                        message: 'Invalid data provided'
                    });
                }
            } catch (error) {
                logError(`Error in identifyUser for socket ${socket.id}:`, error);
                socket.emit('identified', { 
                    status: 'error', 
                    message: 'Internal server error'
                });
            }
        });

        // X·ª≠ l√Ω khi client join v√†o m·ªôt room
        socket.on('join', (room) => {
            socket.join(room);
            logInfo(`Client ${socket.id} joined room: ${room}`);
        });

        // X·ª≠ l√Ω khi client leave m·ªôt room
        socket.on('leave', (room) => {
            socket.leave(room);
            logInfo(`Client ${socket.id} left room: ${room}`);
        });

        // X·ª≠ l√Ω khi client g·ª≠i tin nh·∫Øn
        socket.on('sendMessage', async (data) => {
            logInfo(`Message received from ${socket.id}:`, data);
            
            const { text, recipientId, userId, userName } = data;
            
            // Ki·ªÉm tra text c√≥ t·ªìn t·∫°i v√† kh√¥ng r·ªóng
            if (!text || typeof text !== 'string' || text.trim().length === 0) {
                logError(`Invalid text received from ${socket.id}:`, { text, data });
                socket.emit('messageError', { message: 'Tin nh·∫Øn kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng' });
                return;
            }
            
            // Ki·ªÉm tra xem ng∆∞·ªùi g·ª≠i c√≥ ph·∫£i l√† admin kh√¥ng
            const isAdmin = connectedAdmins.has(socket.id);
            
            if (isAdmin && recipientId) {
                // N·∫øu ng∆∞·ªùi g·ª≠i l√† admin v√† c√≥ recipientId, g·ª≠i tin nh·∫Øn ƒë·∫øn user c·ª• th·ªÉ
                logInfo(`üîç Admin sending message to user ${recipientId}`);
                logInfo(`üîç Connected users:`, Array.from(connectedUsers.keys()));
                logInfo(`üîç User rooms:`, Array.from(connectedUsers.keys()).map(id => `user_${id}`));
                
                const messageData = {
                    senderId: 'admin',
                    senderName: 'Admin',
                    text,
                    timestamp: new Date().toISOString(),
                    isAdmin: true
                };
                
                // L∆∞u tin nh·∫Øn v√†o database
                try {
                    await ChatMessage.create({
                        senderId: 'admin',
                        senderName: 'Admin',
                        recipientId: recipientId,
                        text: text,
                        isAdmin: true,
                        sessionId: `admin_${recipientId}`
                    });
                    logInfo(`‚úÖ Admin message saved to database for user ${recipientId}`);
                } catch (error) {
                    logError('Error saving admin message to database:', error);
                }
                
                // G·ª≠i tin nh·∫Øn ƒë·∫øn user th√¥ng qua room (kh√¥ng c·∫ßn ki·ªÉm tra socket ID)
                const roomName = `user_${recipientId}`;
                logInfo(`üîç Emitting to room: ${roomName}`);
                
                // Ki·ªÉm tra xem c√≥ ai trong room kh√¥ng
                const room = io.sockets.adapter.rooms.get(roomName);
                if (room) {
                    logInfo(`üîç Room ${roomName} has ${room.size} members:`, Array.from(room));
                } else {
                    logInfo(`‚ö†Ô∏è Room ${roomName} is empty or doesn't exist`);
                }
                
                io.to(roomName).emit('receiveMessage', messageData);
                logInfo(`‚úÖ Admin message sent to room ${roomName}`);
                
                // C≈©ng g·ª≠i l·∫°i cho admin ƒë·ªÉ confirm
                socket.emit('receiveMessage', messageData);
                logInfo(`‚úÖ Admin message confirmation sent back to admin`);
                
            } else {
                // Ki·ªÉm tra xem ng∆∞·ªùi g·ª≠i c√≥ ph·∫£i l√† user kh√¥ng
                let senderId = socketToUserId.get(socket.id);
                
                // N·∫øu kh√¥ng t√¨m th·∫•y senderId t·ª´ socket, s·ª≠ d·ª•ng userId t·ª´ data
                if (!senderId && userId) {
                    senderId = userId;
                    // C·∫≠p nh·∫≠t th√¥ng tin socket
                    connectedUsers.set(userId, socket.id);
                    socketToUserId.set(socket.id, userId);
                    socket.join(`user_${userId}`);
                    
                    // L·∫•y th√¥ng tin user t·ª´ database n·∫øu c√≥
                    let userData = { name: userName || 'Unknown User' };
                    if (userId && !userId.startsWith('temp_')) {
                        try {
                            const user = await User.findById(userId).select('fullname email phone');
                            if (user) {
                                userData = { 
                                    name: user.fullname || userName || 'Unknown User',
                                    email: user.email,
                                    phone: user.phone
                                };
                            }
                        } catch (error) {
                            logError(`Error fetching user ${userId}:`, error);
                        }
                    }
                    userInfo.set(userId, userData);
                    logInfo(`User ${userId} (${userData.name}) identified with socket ${socket.id}`);
                }
                
                if (senderId) {
                    // L·∫•y th√¥ng tin user
                    const user = userInfo.get(senderId) || { name: userName || 'Unknown User' };
                    
                    const messageData = {
                        senderId: senderId,
                        senderName: user.name,
                        text,
                        timestamp: new Date().toISOString(),
                        isAdmin: false
                    };
                    
                    // L∆∞u tin nh·∫Øn v√†o database
                    try {
                        await ChatMessage.create({
                            senderId: senderId,
                            senderName: user.name,
                            recipientId: 'admin',
                            text: text,
                            isAdmin: false,
                            userId: senderId.startsWith('temp_') ? null : senderId,
                            sessionId: `admin_${senderId}`
                        });
                    } catch (error) {
                        logError('Error saving user message to database:', error);
                    }
                    
                    // N·∫øu ng∆∞·ªùi g·ª≠i l√† user, g·ª≠i tin nh·∫Øn ƒë·∫øn t·∫•t c·∫£ admin
                    if (connectedAdmins.size > 0) {
                        connectedAdmins.forEach(adminSocketId => {
                            io.to(adminSocketId).emit('receiveMessage', messageData);
                        });
                        logInfo(`User ${senderId} (${user.name}) message sent to all admins`);
                    } else {
                        logInfo(`No admins online to receive message from user ${senderId}`);
                    }
                } else {
                    // N·∫øu kh√¥ng c√≥ senderId, t·∫°o m·ªôt ID t·∫°m th·ªùi v√† l∆∞u th√¥ng tin
                    const tempUserId = userId || `temp_${socket.id.substring(0, 8)}`;
                    const tempUserName = userName || 'Anonymous User';
                    
                    connectedUsers.set(tempUserId, socket.id);
                    socketToUserId.set(socket.id, tempUserId);
                    userInfo.set(tempUserId, { name: tempUserName });
                    socket.join(`user_${tempUserId}`);
                    
                    logInfo(`Created temporary user ${tempUserId} (${tempUserName}) for socket ${socket.id}`);
                    
                    const messageData = {
                        senderId: tempUserId,
                        senderName: tempUserName,
                        text,
                        timestamp: new Date().toISOString(),
                        isAdmin: false
                    };
                    
                    // L∆∞u tin nh·∫Øn v√†o database
                    try {
                        await ChatMessage.create({
                            senderId: tempUserId,
                            senderName: tempUserName,
                            recipientId: 'admin',
                            text: text,
                            isAdmin: false,
                            sessionId: `admin_${tempUserId}`
                        });
                    } catch (error) {
                        logError('Error saving temporary user message to database:', error);
                    }
                    
                    // G·ª≠i tin nh·∫Øn ƒë·∫øn t·∫•t c·∫£ admin
                    if (connectedAdmins.size > 0) {
                        connectedAdmins.forEach(adminSocketId => {
                            io.to(adminSocketId).emit('receiveMessage', messageData);
                        });
                        logInfo(`Temporary user ${tempUserId} (${tempUserName}) message sent to all admins`);
                    } else {
                        logInfo(`No admins online to receive message from temporary user ${tempUserId}`);
                    }
                }
            }
        });

        // X·ª≠ l√Ω khi client y√™u c·∫ßu l·ªãch s·ª≠ tin nh·∫Øn
        socket.on('requestMessageHistory', async (data) => {
            const { userId } = data;
            
            if (userId) {
                try {
                    // L·∫•y tin nh·∫Øn t·ª´ database
                    const messages = await ChatMessage.getMessagesBetweenUsers(userId, 'admin', 100);
                    
                    // Format tin nh·∫Øn
                    const formattedMessages = messages.map(msg => ({
                        senderId: msg.senderId,
                        senderName: msg.senderName,
                        text: msg.text,
                        timestamp: msg.createdAt,
                        isAdmin: msg.isAdmin,
                        isRead: msg.isRead
                    }));
                    
                    socket.emit('messageHistory', formattedMessages);
                    logInfo(`Sent message history to client ${socket.id} for user ${userId}`);
                } catch (error) {
                    logError(`Error fetching message history for user ${userId}:`, error);
                    socket.emit('messageHistory', []);
                }
            } else {
                logInfo(`No userId provided for message history request`);
                socket.emit('messageHistory', []);
            }
        });

        // X·ª≠ l√Ω khi client disconnect
        socket.on('disconnect', () => {
            // X√≥a th√¥ng tin user khi disconnect
            const userId = socketToUserId.get(socket.id);
            if (userId) {
                // Kh√¥ng x√≥a th√¥ng tin user kh·ªèi userInfo v√† messageHistory
                // Ch·ªâ x√≥a th√¥ng tin socket
                connectedUsers.delete(userId);
                socketToUserId.delete(socket.id);
                logInfo(`User ${userId} disconnected`);
            }
            
            // X√≥a th√¥ng tin admin khi disconnect
            if (connectedAdmins.has(socket.id)) {
                connectedAdmins.delete(socket.id);
                logInfo(`Admin disconnected: ${socket.id}`);
            }
            
            logInfo(`Client disconnected: ${socket.id}`);
        });

        // X·ª≠ l√Ω l·ªói
        socket.on('error', (error) => {
            logError(`Socket error for client ${socket.id}:`, error);
        });
    });

    return io;
};

export const getIO = () => {
    if (!io) {
        throw new Error('Socket.IO not initialized!');
    }
    return io;
};

// C√°c h√†m ti·ªán √≠ch ƒë·ªÉ g·ª≠i s·ª± ki·ªán
export const emitToRoom = (room, event, data) => {
    if (!io) return;
    io.to(room).emit(event, data);
};

export const emitToAll = (event, data) => {
    if (!io) return;
    io.emit(event, data);
};

export const emitToUser = (userId, event, data) => {
    if (!io) return;
    io.to(`user_${userId}`).emit(event, data);
};